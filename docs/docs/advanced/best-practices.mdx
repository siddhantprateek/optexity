---
title: Best Practices
description: Tips for building reliable and maintainable automations
---

Building robust browser automations requires thoughtful design. This guide covers best practices learned from real-world Optexity deployments.

## Automation Design

### Start Simple, Then Iterate

Begin with the minimum viable automation:

```json
{
    "nodes": [
        {
            "interaction_action": {
                "click_element": {
                    "command": "get_by_role(\"button\", name=\"Login\")",
                    "prompt_instructions": "Click login"
                }
            }
        }
    ]
}
```

Then add complexity as needed:

- Error handling
- Optional steps
- Extraction actions
- Loops for multiple items

### Use Meaningful Names

For parameters and variables:

```json
{
    "input_parameters": {
        "patient_date_of_birth": ["01/15/1990"],
        "authorization_number": ["AUTH-12345"]
    }
}
```

Avoid:

```json
{
    "input_parameters": {
        "dob": ["01/15/1990"],
        "num": ["AUTH-12345"]
    }
}
```

### Document Complex Logic

Add comments to explain non-obvious steps:

```json
{
    "before_sleep_time": 5.0,
    "extraction_action": {
        "llm": {}
    }
}
```

Handle the optional security question (may not appear):

```json
{
    "interaction_action": {
        "click_element": {
            "prompt_instructions": "Answer security question if present",
            "skip_prompt": true,
            "assert_locator_presence": true
        }
    }
}
```

## Locator Strategy

### Prefer Role-Based Locators

Role-based locators are the most resilient:

```json
{
    "command": "get_by_role(\"button\", name=\"Submit Order\")"
}
```

Good: Label association

```json
{
    "command": "get_by_label(\"Email Address\")"
}
```

Okay: Test IDs (if available)

```json
{
    "command": "get_by_test_id(\"submit-btn\")"
}
```

Last resort: CSS/XPath

```json
{
    "command": "locator(\"#submit-form-btn\")"
}
```

### Always Provide prompt_instructions

Even with reliable locators, always provide a fallback:

```json
{
    "click_element": {
        "command": "get_by_role(\"button\", name=\"Continue\")",
        "prompt_instructions": "Click the green Continue button at the bottom of the form"
    }
}
```

### Handle Dynamic IDs

Never rely on dynamic IDs:

Bad: ID changes every page load

```json
{
    "command": "locator(\"#btn_12345_submit\")"
}
```

Good: Use stable attributes

```json
{
    "command": "get_by_role(\"button\", name=\"Submit\")"
}
```

```json
{
    "command": "locator(\"[data-action='submit']\")"
}
```

## When to Use Extraction

### Extract Before Acting on Dynamic Content

```json
{
    "extraction_action": {
        "llm": {
            "extraction_format": {
                "item_ids": "List[str]"
            },
            "output_variable_names": ["item_ids"],
            "extraction_instructions": "Extract all item IDs from the list",
            "source": ["axtree"]
        }
    }
}
```

Then: Act on them

```json
{
    "variable_name": "item_ids",
    "nodes": []
}
```

### Extract for Validation

Use extraction to verify state:

```json
{
    "extraction_action": {
        "llm": {
            "extraction_format": {
                "confirmation_number": "str",
                "status": "str"
            },
            "extraction_instructions": "Extract the confirmation number and status message",
            "source": ["axtree"]
        }
    }
}
```

### Choose the Right Source

| Scenario                    | Source                     |
| --------------------------- | -------------------------- |
| Tables, forms, text content | `["axtree"]`               |
| Visual layouts, images      | `["screenshot"]`           |
| Complex pages               | `["axtree", "screenshot"]` |

## Timing Best Practices

### Wait Before Extraction

Pages need time to load:

```json
{
    "extraction_action": {
        "llm": {}
    },
    "before_sleep_time": 3.0
}
```

### Wait After Navigation

Give pages time to render:

```json
{
    "interaction_action": {
        "click_element": {
            "command": "get_by_role(\"link\", name=\"Dashboard\")",
            "prompt_instructions": "Navigate to dashboard"
        }
    },
    "end_sleep_time": 2.0
}
```

### Use Retries for Dynamic Elements

For elements that appear after JavaScript loads:

```json
{
    "interaction_action": {
        "max_tries": 15,
        "max_timeout_seconds_per_try": 1.0,
        "click_element": {
            "command": "get_by_text(\"Results loaded\")",
            "prompt_instructions": "Wait for results to load"
        }
    }
}
```

## Error Handling

### Handle Optional Elements

Use `assert_locator_presence` for elements that may not appear:

```json
{
    "interaction_action": {
        "click_element": {
            "command": "get_by_role(\"button\", name=\"Accept Cookies\")",
            "prompt_instructions": "Accept cookies if banner appears",
            "assert_locator_presence": true
        }
    }
}
```

### Use skip_prompt for Known Optional Steps

```json
{
    "interaction_action": {
        "click_element": {
            "command": "get_by_role(\"button\", name=\"Skip Tutorial\")",
            "prompt_instructions": "Skip tutorial if shown",
            "skip_prompt": true,
            "assert_locator_presence": true
        }
    }
}
```

### Handle Multiple Paths

Structure automations to handle variations:

```json
{
    "interaction_action": {
        "click_element": {
            "command": "get_by_role(\"button\", name=\"Continue\")",
            "prompt_instructions": "Click Continue to proceed"
        }
    }
}
```

Some flows show a different button:

```json
{
    "interaction_action": {
        "click_element": {
            "command": "get_by_role(\"button\", name=\"Next\")",
            "prompt_instructions": "Click Next if Continue wasn't found",
            "skip_prompt": true,
            "assert_locator_presence": true
        }
    }
}
```

## Security Best Practices

### Never Hardcode Credentials

```json
{
    "input_parameters": {
        "password": ["actualpassword123"]
    }
}
```

Good: Pass at runtime via API

```json
{
    "input_parameters": {
        "password": []
    }
}
```

### Protect Sensitive Data

- Use environment variables for API keys
- Store credentials securely
- Avoid logging sensitive values

## Performance Tips

### Minimize Unnecessary Waits

```json
{
    "interaction_action": {},
    "before_sleep_time": 0.0,
    "end_sleep_time": 0.5
}
```

### Use Static Actions Over Agentic

Agentic tasks are powerful but slower:

```json
{
    "click_element": {
        "command": "get_by_role(\"button\", name=\"Submit\")",
        "prompt_instructions": "Click submit"
    }
}
```

Use agentic only for unpredictable UI:

```json
{
    "agentic_task": {
        "task": "Handle CAPTCHA if present",
        "max_steps": 5
    }
}
```

### Batch Extractions

Extract multiple fields at once:

```json
{
    "llm": {
        "extraction_format": {
            "name": "str",
            "email": "str",
            "phone": "str",
            "address": "str"
        },
        "extraction_instructions": "Extract all contact information"
    }
}
```

Avoid: Multiple separate extractions

## Debugging Tips

### Check Locators First

When actions fail:

1. Verify the element exists on the page
2. Test the locator in browser DevTools
3. Check if the element is inside an iframe
4. Look for dynamic class/ID changes

### Review Timing

Common timing issues:

| Symptom                  | Solution                        |
| ------------------------ | ------------------------------- |
| "Element not found"      | Increase `before_sleep_time`    |
| Wrong element clicked    | Wait for page to settle         |
| Extraction returns empty | Increase wait before extraction |
| Random failures          | Increase retry count            |

### Use Screenshots for Debugging

Add screenshot extractions to capture state:

```json
{
    "extraction_action": {
        "screenshot": {
            "filename": "debug_before_submit.png",
            "full_page": true
        }
    }
}
```

### Start with Verbose Logging

During development, add extraction steps to see page state:

```json
{
    "extraction_action": {
        "llm": {
            "source": ["axtree"],
            "extraction_format": {
                "page_state": "str"
            },
            "extraction_instructions": "Describe what's on the current page"
        }
    }
}
```

## Common Patterns

### Login Flow

```json
{
    "nodes": [
        {
            "interaction_action": {
                "input_text": {
                    "command": "get_by_label(\"Email\")",
                    "input_text": "{email[0]}",
                    "prompt_instructions": "Enter email"
                }
            }
        },
        {
            "interaction_action": {
                "input_text": {
                    "command": "get_by_label(\"Password\")",
                    "input_text": "{password[0]}",
                    "prompt_instructions": "Enter password"
                }
            }
        },
        {
            "interaction_action": {
                "click_element": {
                    "command": "get_by_role(\"button\", name=\"Sign In\")",
                    "prompt_instructions": "Click sign in"
                }
            }
        },
        {
            "before_sleep_time": 3.0,
            "extraction_action": {
                "llm": {
                    "extraction_format": {
                        "logged_in": "str"
                    },
                    "extraction_instructions": "Confirm we're logged in by looking for dashboard elements",
                    "source": ["axtree"]
                }
            }
        }
    ]
}
```

### Search and Process Results

```json
{
    "nodes": [
        {
            "interaction_action": {
                "input_text": {
                    "command": "get_by_role(\"searchbox\")",
                    "input_text": "{query[0]}",
                    "prompt_instructions": "Enter search query"
                }
            }
        },
        {
            "interaction_action": {
                "click_element": {
                    "command": "get_by_role(\"button\", name=\"Search\")",
                    "prompt_instructions": "Click search"
                }
            }
        },
        {
            "before_sleep_time": 3.0,
            "extraction_action": {
                "llm": {
                    "extraction_format": {
                        "result_ids": "List[str]"
                    },
                    "output_variable_names": ["result_ids"],
                    "extraction_instructions": "Extract all result IDs",
                    "source": ["axtree"]
                }
            }
        },
        {
            "variable_name": "result_ids",
            "nodes": [
                {
                    "interaction_action": {
                        "click_element": {
                            "command": "get_by_text(\"{result_ids[index]}\")",
                            "prompt_instructions": "Click result {result_ids[index]}"
                        }
                    }
                },
                {
                    "interaction_action": {
                        "go_back": {}
                    }
                }
            ]
        }
    ]
}
```

## Checklist

Before deploying an automation:

- [ ] All locators have `prompt_instructions`
- [ ] Sensitive data passed via parameters, not hardcoded
- [ ] Appropriate wait times for page loads
- [ ] Optional elements handled with `assert_locator_presence`
- [ ] Error cases considered
- [ ] Tested on realistic data
- [ ] Variable names are descriptive
- [ ] Complex logic is commented
