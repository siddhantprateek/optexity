---
title: Agentic Tasks
description: Using AI agents for complex browser interactions
---

Sometimes web interactions are too complex or unpredictable for static automations. Optexity integrates with AI agents that can autonomously navigate and interact with web pages to accomplish goals.

## Overview

Agentic tasks use a language model to control the browser, making decisions about what to click, type, and navigate based on the current page state and a goal description.

Two agentic action types are available:

| Action | Purpose |
|--------|---------|
| `agentic_task` | General-purpose autonomous task execution |
| `close_overlay_popup` | Specialized for dismissing popups and modals |

## AgenticTask

Use `AgenticTask` when you need the AI to autonomously accomplish a goal.

```python
from optexity.schema.automation import ActionNode
from optexity.schema.actions.interaction_action import (
    InteractionAction,
    AgenticTask,
)

ActionNode(
    interaction_action=InteractionAction(
        agentic_task=AgenticTask(
            task="Navigate to the settings page and enable two-factor authentication",
            max_steps=15,
            backend="browser_use",
            use_vision=False,
            keep_alive=True,
        )
    )
)
```

### Properties

| Property | Type | Default | Description |
|----------|------|---------|-------------|
| `task` | `str` | Required | Natural language description of the goal |
| `max_steps` | `int` | Required | Maximum number of actions the agent can take |
| `backend` | `"browser_use" \| "browserbase"` | Required | Agent backend to use |
| `use_vision` | `bool` | `False` | Whether the agent should use screenshots |
| `keep_alive` | `bool` | `True` | Keep browser session alive after task |

### Writing Good Task Descriptions

The `task` field should clearly describe the goal:

**Good examples:**

```python
# Specific and actionable
task="Click the 'Account Settings' link in the sidebar, then scroll down and click 'Security'"

# Clear success criteria
task="Fill out the contact form with name 'John Doe', email 'john@example.com', and message 'Hello', then submit"

# Step-by-step when needed
task="1. Close any popup dialogs 2. Click the search icon 3. Search for 'laptop' 4. Click the first result"
```

**Poor examples:**

```python
# Too vague
task="Do the thing"

# Ambiguous
task="Complete the form"

# No clear end state
task="Browse the website"
```

### max_steps Configuration

Set `max_steps` based on task complexity:

| Task Complexity | Suggested max_steps |
|-----------------|---------------------|
| Simple (1-2 clicks) | 3-5 |
| Medium (navigate, fill form) | 10-15 |
| Complex (multi-page workflow) | 20-30 |

<Warning>
Higher `max_steps` means longer execution time and higher LLM costs. Start low and increase if needed.
</Warning>

### Backend Options

| Backend | Description |
|---------|-------------|
| `browser_use` | Local browser-use agent (default) |
| `browserbase` | Cloud-based browser automation |

### use_vision

When `use_vision=True`, the agent receives screenshots:

```python
AgenticTask(
    task="Click on the red 'Sale' banner",
    max_steps=5,
    backend="browser_use",
    use_vision=True,  # Agent can "see" the page
)
```

Use vision for:
- Visual elements without good text/ARIA labels
- Image-based navigation
- Verifying visual state

Avoid vision when:
- Text-based navigation is sufficient
- Speed is critical
- Minimizing LLM costs

## CloseOverlayPopupAction

A specialized agentic task for dismissing popups, modals, and overlays.

```python
from optexity.schema.actions.interaction_action import (
    InteractionAction,
    CloseOverlayPopupAction,
)

ActionNode(
    interaction_action=InteractionAction(
        close_overlay_popup=CloseOverlayPopupAction(
            max_steps=5,
        )
    )
)
```

### Default Behavior

`CloseOverlayPopupAction` comes with pre-configured defaults:

| Property | Default Value |
|----------|---------------|
| `task` | Comprehensive popup dismissal prompt |
| `max_steps` | `5` |
| `backend` | `"browser_use"` |
| `use_vision` | `True` |
| `keep_alive` | `True` |

### What It Handles

The built-in prompt instructs the agent to dismiss:

- Cookie consent banners
- Privacy policy notices
- Email/newsletter signup prompts
- Age verification gates
- Promotional offer popups
- Any blocking overlay

### Priority Rules

The agent follows these rules:

1. **Cookie consent**: Always accept/agree
2. **Other popups**: Click dismissive buttons (Close, X, No Thanks, Skip)
3. **Avoidance**: Never input text or click signup/learn more links

### When to Use

```python
# At the start of an automation to clear the page
ActionNode(
    interaction_action=InteractionAction(
        close_overlay_popup=CloseOverlayPopupAction(max_steps=5)
    ),
    before_sleep_time=3.0,  # Wait for popups to appear
),

# Before extracting data
ActionNode(
    extraction_action=ExtractionAction(...)
),
```

## Using Variables in Agentic Tasks

Variables can be substituted in the `task` field:

```python
parameters=Parameters(
    input_parameters={
        "search_query": ["laptop"],
        "price_max": ["1000"],
    },
    ...
),

ActionNode(
    interaction_action=InteractionAction(
        agentic_task=AgenticTask(
            task="Search for '{search_query[0]}' and filter results to show items under ${price_max[0]}",
            max_steps=10,
            backend="browser_use",
        )
    )
),
```

## Combining Agentic with Static Actions

Agentic tasks work best as part of a larger automation:

```python
# Static: Login with known credentials
ActionNode(
    interaction_action=InteractionAction(
        input_text=InputTextAction(
            command="""get_by_label("Email")""",
            input_text="{email[0]}",
            prompt_instructions="Enter email",
        )
    )
),
ActionNode(
    interaction_action=InteractionAction(
        input_text=InputTextAction(
            command="""get_by_label("Password")""",
            input_text="{password[0]}",
            prompt_instructions="Enter password",
        )
    )
),
ActionNode(
    interaction_action=InteractionAction(
        click_element=ClickElementAction(
            command="""get_by_role("button", name="Sign In")""",
            prompt_instructions="Click sign in",
        )
    )
),

# Agentic: Handle variable dashboard navigation
ActionNode(
    interaction_action=InteractionAction(
        agentic_task=AgenticTask(
            task="Navigate to the Reports section and find the Monthly Summary report",
            max_steps=10,
            backend="browser_use",
        )
    )
),

# Static: Download the report
ActionNode(
    interaction_action=InteractionAction(
        click_element=ClickElementAction(
            command="""get_by_role("button", name="Download")""",
            prompt_instructions="Download the report",
            expect_download=True,
        )
    )
),
```

## When to Use Agentic Tasks

<CardGroup cols={2}>
<Card title="Use Agentic For" icon="check">
  - Unpredictable UI layouts
  - Complex navigation paths
  - Handling popups/modals
  - Sites with frequent changes
  - Multi-step form wizards
</Card>
<Card title="Prefer Static For" icon="x">
  - Known, stable elements
  - Simple click/type actions
  - Performance-critical paths
  - Cost-sensitive automations
  - Deterministic workflows
</Card>
</CardGroup>

## Error Handling

Agentic tasks can fail if:

- The goal can't be achieved within `max_steps`
- The page state prevents the action
- The LLM makes incorrect decisions

Consider adding fallback static actions:

```python
# Try agentic approach first
ActionNode(
    interaction_action=InteractionAction(
        agentic_task=AgenticTask(
            task="Find and click the logout button",
            max_steps=5,
            backend="browser_use",
        )
    )
),

# Fallback: direct locator if agentic fails
ActionNode(
    interaction_action=InteractionAction(
        click_element=ClickElementAction(
            command="""get_by_role("button", name="Logout")""",
            prompt_instructions="Click logout",
            skip_prompt=True,
            assert_locator_presence=True,
        )
    )
),
```

## Best Practices

### Start with Static Actions

Use static actions for predictable interactions:

```python
# Good: Static for known elements
ClickElementAction(
    command="""get_by_role("button", name="Submit")""",
    ...
)

# Save agentic for the complex parts
AgenticTask(
    task="Handle any CAPTCHA that appears",
    ...
)
```

### Keep Tasks Focused

Break complex goals into smaller agentic tasks:

```python
# Instead of one big task
AgenticTask(task="Sign up for an account, verify email, and complete profile")

# Use multiple focused tasks
AgenticTask(task="Fill out the signup form with the provided information"),
AgenticTask(task="Click the verification link in the confirmation page"),
AgenticTask(task="Complete the profile setup wizard"),
```

### Monitor and Iterate

Agentic tasks may need tuning:

- Review execution logs
- Adjust `max_steps` based on actual usage
- Refine `task` descriptions for clarity
- Consider `use_vision` for visual-heavy pages

## Next Steps

- See [Interaction Actions](/docs/interaction-actions) for static alternatives
- Check [Timing & Retries](/docs/timing-retries) for agentic task timing
- Learn [Best Practices](/docs/best-practices) for reliable automations

