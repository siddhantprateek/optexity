---
title: Locators
description: Finding elements on the page reliably
---

Optexity provides multiple ways to locate elements on a webpage. Understanding when to use each method is key to building robust automations.

## Overview

Every interaction action has three ways to find elements:

| Method | Field | When to Use |
|--------|-------|-------------|
| **Playwright Command** | `command` | Preferred. Uses Playwright's robust locator API |
| **XPath** | `xpath` | Alternative for complex DOM traversal |
| **AI Fallback** | `prompt_instructions` | Always provide. Used when locators fail |

## Playwright Commands

The `command` field accepts Playwright locator syntax. These are evaluated at runtime against the page.

### Role-Based Locators (Recommended)

Find elements by their ARIA role and accessible name:

```python
# Buttons
command="""get_by_role("button", name="Submit")"""
command="""get_by_role("button", name="Sign In")"""

# Links
command="""get_by_role("link", name="Learn More")"""

# Text inputs
command="""get_by_role("textbox", name="Email")"""
command="""get_by_role("textbox", name="Password")"""

# Checkboxes and radio buttons
command="""get_by_role("checkbox", name="Remember me")"""
command="""get_by_role("radio", name="Express shipping")"""

# Dropdowns
command="""get_by_role("combobox", name="Country")"""

# Headings
command="""get_by_role("heading", name="Welcome")"""
```

Role-based locators are the most resilient because they:
- Don't depend on CSS classes or IDs that may change
- Match how users perceive the page
- Work across different implementations of the same component

### Text-Based Locators

Find elements by their visible text content:

```python
# Exact text match
command="""get_by_text("Welcome back")"""

# Partial text match (default)
command="""get_by_text("Welcome")"""  # Matches "Welcome back" too

# Exact match only
command="""get_by_text("Welcome", exact=True)"""
```

### Label-Based Locators

Find form elements by their associated label:

```python
command="""get_by_label("Email address")"""
command="""get_by_label("Password")"""
command="""get_by_label("I agree to the terms")"""
```

### Test ID Locators

Find elements with `data-testid` attributes (common in modern apps):

```python
command="""get_by_test_id("login-button")"""
command="""get_by_test_id("email-input")"""
command="""get_by_test_id("submit-form")"""
```

### CSS Selector Locators

For when you need direct CSS selector access:

```python
# By ID
command="""locator("#email-input")"""

# By class
command="""locator(".submit-button")"""

# Complex selectors
command="""locator("form.login input[type='email']")"""

# Attribute selectors
command="""locator("[data-action='submit']")"""
```

### Chaining Locators

Narrow down to specific elements by chaining:

```python
# Find link within a specific section
command="""get_by_role("navigation").get_by_role("link", name="Home")"""

# Find button within a form
command="""locator("form#login").get_by_role("button", name="Submit")"""

# Find element within labeled section
command="""get_by_label("Shipping Address").get_by_role("textbox", name="Street")"""
```

### Working with Iframes

Access elements inside iframes using `content_frame`:

```python
# Simple iframe
command="""locator('#login-iframe').content_frame.get_by_role('button', name='Submit')"""

# Iframe by name
command="""locator("iframe[name='payment']").content_frame.get_by_label("Card Number")"""

# Nested access
command="""locator('#outer-iframe').content_frame.locator('#inner-form').get_by_role('button')"""
```

## XPath Locators

Use XPath when you need complex DOM traversal that Playwright locators can't express:

```python
ActionNode(
    interaction_action=InteractionAction(
        click_element=ClickElementAction(
            xpath="//table[@id='results']//tr[contains(@class, 'active')]/td[3]/button",
            prompt_instructions="Click the action button in the active row",
        )
    )
)
```

<Warning>
XPath locators are more fragile than Playwright commands. Prefer `command` when possible.
</Warning>

### Common XPath Patterns

```python
# By text content
xpath="//button[text()='Submit']"

# Contains text
xpath="//div[contains(text(), 'Welcome')]"

# By attribute
xpath="//input[@type='email']"

# Ancestor/descendant
xpath="//form[@id='login']//button[@type='submit']"

# Position-based
xpath="//ul/li[3]/a"  # Third list item's link
```

## Prompt Instructions

The `prompt_instructions` field provides a natural language description of the element. This is used when:

1. The `command` or `xpath` locator fails to find an element
2. You want the AI to choose from multiple possible elements
3. The element's identifier changes dynamically

```python
ActionNode(
    interaction_action=InteractionAction(
        click_element=ClickElementAction(
            command="""get_by_role("button", name="Continue")""",
            prompt_instructions="Click the green Continue button at the bottom of the checkout form",
        )
    )
)
```

### Writing Good Prompt Instructions

<CardGroup cols={2}>
<Card title="Be Specific" icon="bullseye">
  Include visual details, position, and context
</Card>
<Card title="Add Context" icon="map">
  Reference nearby elements or sections
</Card>
</CardGroup>

**Good examples:**

```python
# Position and visual context
prompt_instructions="Click the blue 'Add to Cart' button below the product price"

# Reference to nearby elements
prompt_instructions="Click the Submit button next to the Cancel button at the bottom of the form"

# Dynamic content handling
prompt_instructions="Click on order number {order_id[0]} in the orders table"
```

**Poor examples:**

```python
# Too vague
prompt_instructions="Click the button"

# Doesn't help locate
prompt_instructions="Click it"
```

## Locator Selection Strategy

Follow this decision tree for choosing locators:

```
1. Does the element have a role and accessible name?
   → Use get_by_role()

2. Is it a form element with a label?
   → Use get_by_label()

3. Does it have a data-testid attribute?
   → Use get_by_test_id()

4. Does it have unique visible text?
   → Use get_by_text()

5. Does it have a unique ID or class?
   → Use locator() with CSS selector

6. Need complex DOM traversal?
   → Use xpath

7. Element varies or is dynamic?
   → Use prompt_instructions primarily
```

## Dynamic Elements

For elements that change between runs, use variables in your locators:

```python
# Using input parameters
command="""get_by_text("{order_id[0]}")"""

# Using extracted values in loops
command="""get_by_role("link", name="{product_names[index]}")"""
```

Always provide descriptive `prompt_instructions` as backup:

```python
prompt_instructions="Click on the row containing order {order_id[0]}"
```

## Assert Locator Presence

When you want to verify an element exists before attempting interaction (useful for optional steps):

```python
ActionNode(
    interaction_action=InteractionAction(
        click_element=ClickElementAction(
            command="""get_by_role("button", name="Proceed")""",
            prompt_instructions="Click the Proceed button if visible",
            assert_locator_presence=True,  # Skip if not found
        )
    )
)
```

When `assert_locator_presence=True`:
- The action checks if the locator finds an element
- If not found, it skips the action instead of failing
- Useful for dismiss dialogs, optional popups, or conditional UI

## Next Steps

- Learn about [Parameters and Variables](/docs/parameters-variables) for dynamic values
- See [Interaction Actions](/docs/interaction-actions) for all available actions
- Check [Best Practices](/docs/best-practices) for tips on building reliable automations

